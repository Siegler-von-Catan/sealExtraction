import cv2 as cv
import imutils
import numpy as np

def getSaliencyMask(waxSegmentedImage):
    waxSegmentedImageCopy = waxSegmentedImage.copy()
    waxSegmentedImageCopy = imutils.resize(waxSegmentedImageCopy, width=900)
    waxSegmentedImageCopy = preProcessForSaliency(waxSegmentedImageCopy)

    threshMap =  getSaliencyThreshMap(waxSegmentedImageCopy)
    threshMap = postProcessThreshMask(threshMap)
    threshMap = cv.resize(threshMap,(waxSegmentedImage.shape[1], waxSegmentedImage.shape[0]))

    return threshMap

def preProcessForSaliency(waxSegmentedImage):
    filter_kernel = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]])
    waxSegmentedImage = cv.filter2D(waxSegmentedImage, -1, filter_kernel)
    waxSegmentedImage = cv.GaussianBlur(waxSegmentedImage, (13, 13), 0)
    return waxSegmentedImage

def getSaliencyThreshMap(image):
    saliency = cv.saliency.StaticSaliencyFineGrained_create()
    (success, saliencyMap) = saliency.computeSaliency(image)
    saliencyMap = (saliencyMap * 255).astype("uint8")
    threshMap = cv.threshold(saliencyMap,0,255,cv.THRESH_BINARY | cv.THRESH_OTSU)[1]
    return threshMap

def postProcessThreshMask(threshMap):
    contours = cv.findContours(threshMap.copy(), cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE)
    contours = imutils.grab_contours(contours)
    contours = sorted(contours, key=cv.contourArea, reverse=True)

    splittingIndex = 10
    interestingContours = contours[:splittingIndex]
     # the first two contours are always from the wax and the shadow generated by saliency so leave them out...
    interestingContours.pop(0)
    interestingContours.pop(1)
    # ...and delete the shadow by filling the borders between the first two contours black
    threshMap = deleteShadow(threshMap, contours[1])

    deleteUninterestingContours(contours, threshMap, splittingIndex)
    return threshMap

def deleteUninterestingContours(allContours, maskToDrawOn, splittingIndex):
    """
    Delete all contours of the mask which are beyong the splittingIndex
    of the given list containing all contours
    """
    uninterestingContours = allContours[splittingIndex:]
    for (_i, c) in enumerate(uninterestingContours):
        cv.fillPoly(maskToDrawOn, pts =[c], color=(0,0,0))

def deleteShadow(saliencyTreshMap, innerShadowContour):
    """
    Static saliency creates a shadow around the object which becomes part of the mask we want to create.
    Delete it by overdrawing it
    """
    shadowMask = np.zeros(saliencyTreshMap.shape[:2],np.uint8)
    cv.fillPoly(shadowMask, pts =[innerShadowContour], color=(255,255,255))
    shadowMask = cv.bitwise_and(saliencyTreshMap, saliencyTreshMap, mask = shadowMask)
    # In some cases, there is no shadow (if the mask is also touching image borders)
    # Check and return the orignal just in case
    contours = cv.findContours(shadowMask, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE)
    contours = imutils.grab_contours(contours)

    # also, with so few contours we might have grapped the wrong contour and could not do anything
    # with the shadowMask. so take the lesser evil and accept the shadow
    if len(contours) <= 20:
        return saliencyTreshMap
    else:
        return shadowMask
